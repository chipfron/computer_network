- 测试用例的<mark style="background: #FF5582A6;">目的</mark>：
	1. 确定一组最有可能发现某个错误或某类错误的测试数据。
- 测试用例的不足：
	1. 不可能测试程序的每条路径，也不能把所有数据都试一遍， 设计人员必须努力以最少量的测试用例来发现最大量的可能错误。
- 测试用例的两种技术：
	1. 黑盒技术：着重测试<mark style="background: #FF5582A6;">软件功能</mark>。
	2. 白盒技术：是以程序的<mark style="background: #FF5582A6;">内部逻辑结构</mark>为基础设计测试用例，被检测的对象是源程序。
- 黑盒技术：着重测试软件<mark style="background: #FF5582A6;">功能</mark>，设计测试用例时，需要研究需求说明和总体设计说明中的有关程序功能或输入、输出之间的关系等信息，从而与测 试后的结果进行分析比较。
	1. 测试人员将程序看成是一个“黑盒”，不深入代码细节的测试方法称为动态黑盒测试。
	2. 黑盒法是把测试对象看作一个黑盒，测试时完全不考虑程序的内部的逻辑结构与内部特性，只需根据<mark style="background: #FF5582A6;">需求规格说明书</mark>，测试程序的<mark style="background: #FF5582A6;">功能</mark>或程序的<mark style="background: #FF5582A6;">外部特性</mark>。<mark style="background: #FF5582A6;">即不关心程序内部是什么，只要检查程序是否符合它的“功能说明”</mark>。因此黑盒法又称为功能测试或数据驱动测试。
	3. 黑盒法特点：
		- 应用黑盒法时，手头只需有程序的功能说明书就够了。
		- 使用白盒法设计测试用例时，只需要选择一个覆 盖标准，而使用黑盒法进行测试，则应该同时使用 多种黑盒测试方法，才能得到较好的测试效果。
		- 黑盒测试着重测试软件功能。但黑盒测试并不能取代白盒测试，它是与白盒测试互补的测试方法，它很可能发现白盒测试不易发现的其他类型的错误；
		- 黑盒测试力图发现下述类型的错误：
			1. 功能不正确或遗漏了功能
			2. 界面错误
			3. 数据结构错误或外部数据库访问错误
			4. 性能错误
			5. 初始化和终止错误
	4. 设计黑盒测试方案时，应该考虑下述问题：
		- 怎样测试功能的有效性？
		- 哪些类型的输入可构成好测试用例？
		- 系统是否对特定的输入值特别敏感？
		- 怎样划定数据类的边界？
		- 系统能够承受什么样的数据率和数据量？
		- 数据的特定组合将对系统运行产生什么影响？
	5. 常用的黑盒测试方法有三种：
		- 等价分类法
			1. 等价类划分：把程序的输入域划分成若干个数据类，然后从每一等价类中选择出<mark style="background: #FF5582A6;">少数有代表性的数据做为测试用例</mark>，据此导出测试用例。一个理想的测试用例能独自发现一类错误。
			2. 穷尽的黑盒测试（即用所有有效的和无效的输入数据来测试程序）通常是不现实的。因此，只能选取少量最有代表性的输入数据作为测试数据，以期用较小的代价暴露出较多的程序错误。
			3. 步骤：<mark style="background: #FF5582A6;">划分等价类</mark>（列出等价类表）和<mark style="background: #FF5582A6;">选取测试用例</mark>。
				- 第一步：划分等价类
					1. 等价类是指某个输入域的子集合。在该子集合中，<mark style="background: #FF5582A6;">各个输入数据对于揭露程序中的错误都是等效的</mark>。测试某等价类的代表值就等价于对这一类其它值的测试。
					2.  等价类的划分有两种不同的情况：
						- <mark style="background: #FF5582A6;">有效等价类</mark>：是指对于程序的规格说明来说 ，是合理的，有意义的输入数据构成的集合。
						- <mark style="background: #FF5582A6;">无效等价类</mark>：是指对于程序的规格说明来说 ，是不合理的，无意义的输入数据构成的集合 。
					3. 在设计测试用例时，要同时考虑有效等价类和 无效等价类的设计。
					4. 划分等价类的原则：
						- 如果规定了输入值的范围，则可划分出一个有效的等价类 ( 输入值在此范围内 ) ，两个无效的等价类 ( 输入值小于最小值或大于最大值 ) ；
							如“数据值”是从 1 到 999 ，则
							1. 有效等价类：大于 1 而小于等于 999 的数
							2. 无效等价类：小于 1 的数；大于 999 的数
						- 如果规定了输入数据的个数，则类似地也可 以划分出一个有效的等价类和两个无效的等价类；
							如每个学生可以选修 1 至 3 门课程，则
							1. 有效等价类：选修 1—3 门课程；
							2. 无效等价类：没有选修课程；超过 3 门课程
						- 如果规定了输入数据必须遵循的规则，则可 以划分出一个有效的等价类 ( 符合规则 ) 和若干个 无效的等价类 ( 从各种不同角度违反规则 ) ；
							如职称的输入值可以是助教、讲师、副教授和教 授 4 种 ) ，则
							1. 有效等价类 : 助教、讲师、副教授和教授 4 种 ;
							2. 无效等价类 : 上述 4 种职称之外的任意值。
				- 第二步：选择测试用例
					1. 为每个等价类编号；
					2. 设计一个新的测试用例，使它能包括尽可能多的 尚未被包括的合理等价类；重复做这一步，直至这 些测试用例已包括所有的合理等价类；
					3. 设计一个新的测试用例，使它包括一个尚未被包 括的不合理等价类，重复做这一步，直至测试用例已 包括所有的不合理等价类。
		- 边值分析法
			1. 边界值分析也是一种黑盒测试方法，是对等价类划 分方法的补充。
			2. 人们从长期的测试工作经验得知，大量的错误是发 生在输入或输出范围的边界上，而不是在输入范围 的内部。因此针对各种边界情况设计测试用例，可 以查出更多的错误。
			3. 比如，在做三角形计算时，要输入三角形的三个 边长： A 、 B 和 C 。 我们应注意到这三个数值 应当满足：A ＞ 0 、 B ＞ 0 、 C ＞ 0 、 A ＋ B ＞ C 、 A ＋ C ＞ B 、 B ＋ C ＞ A，才 能构成三角形。但如果把六个不等式中的任何一 个大于号“＞”错写成大于等于号“≥”，那就 不能构成三角形。问题恰出现在容易被疏忽的边 界附近。
			4. 使用边界值分析方法设计测试用例，首先应确定 边界情况。应当选取正好等于，刚刚大于，或刚 刚小于边界的值做为测试数据，而不是选取等价 类中的典型值或任意值做为测试数据。
			5. 运用边界值分析法，需要有一定的创造性， 以下几点供使用时参考：
				- 如果某个输入条件说明了值的范围，则可选择 一些恰好取到边界值的例子，另外，再编写一些代 表不合理输入数据的例子，它们的值恰好越过边界。 
					例如：输入值的范围是 -1.0 至 1.0 ，则可选 - 1.0 、 1.0 、 -1.001 和 1.001 等例子。
				- 如果一个输入条件指出了输入数据的个数，则 为最小个数、最大个数、比最小个数少 1 、比最 大个数多 1 、分别设计例子。
					例如：一个输入文件可以有 1 ～ 255 个记录， 则分别设计有 0 个、 1 个、 255 个和 256 个记录的输入文件。
				- 如果程序的输入和输出是有序集合 ( 如顺序文 件、线性表等 ) ，则应特别注意集合的第一个或最 后一个元素
				- 注意：等价分类法与边界值分析法的主要差别在于 后者是着重检查等价类边界上的情况。
		- 错误推测法
			1. 靠经验和直觉推测程序中可能存在的各种错 误，从而有针对性地编写检查这些错误的测试 用例。这就是错误推测法。
			2. 错误推测法的基本想法是：列举出程序中所有 可能有的错误和容易发生错误的特殊情况，根 据它们选择测试用例。
			3. 错误推测法的特点：没有确定的步骤，很大程度上 是凭经验进行的。例如输入数据为零或输出数据为 零是容易发生错误的情况，所以可选择输入值为零 的例子，以及使输出值为零的例子；又如输入表格 为“空”或输入表格只有一行是较易出错误的情况 ，所以可选择表示这些情况的例子。
			4. 错误推测法是一种简单易行的黑盒法，但由于 该方法有较大的随意性，主要依赖于测试者的经验， 因此通常作为一种辅助的黑盒测试方法。
- 白盒技术：以<mark style="background: #FF5582A6;">程序的结构</mark>为依据，被测对象基本上是源程序，以程序的内部逻辑结构为基础设计测试用例。
	1. 白盒法又称为逻辑覆盖法，是一种以程序（模块）内部的逻辑结构为基础来设计测试用例的方法，对程序所有逻辑路径进行测试。它主要用于<mark style="background: #FF5582A6;">单元测试</mark>。
	2. 白盒法的特点：
		- 需了解程序内部的结构；
		- 测试用例是根据程序的内部逻辑来设计的；
		- 如果想用白盒法发现程序中所有的错误，则至少必须使程序中每种可能的路径都执行一次；
		- 应用白盒法时，需要有程序的<mark style="background: #FF5582A6;">功能说明书</mark>和<mark style="background: #FF5582A6;">程序清单</mark>。
	3. 软件人员使用白盒测试方法，主要想对程序模块进行如下的检查：
		- 对程序模块的所有独立的执行路径至少测试一次；
		- 对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；
		- 在循环的边界和运行界限内执行循环体；
		- 测试内部数据结构的有效性等。
	4. 白盒的测试以程序的结构为依据，所以又称为结构测试。
	5. 早期的白盒的测试把注意力放在<mark style="background: #FF5582A6;">流程图的各个判定框</mark>上，使用不同的逻辑覆盖标准来表达对程序测试的详尽程度。
	6. 随着测试技术的发展，人们越来越重视测试对程序的<mark style="background: #FF5582A6;">执行路径</mark>的考察，并且用流图代替流程图来设计测试用例。
	7. 为了区分这两种白盒测试技术，把前者称为逻辑覆盖测试，后者称为路径测试。
		- 逻辑覆盖测试法
			1. 逻辑覆盖测试法用流程图来设计测试，它考察的重点是图中的判定框（菱形框）。因为这些判定若不是与选择有关，就是与循环结构有关。是决定程序结构的关键成分。
			2. 按照对被测程序所作测试的有效程度，逻辑覆盖测试可由弱到强区分为 5 种覆盖标准，如下图所示：
				- ![[Pasted image 20230624155451.png]]
					1. 语句覆盖
						- 语句覆盖选择足够的测试用例，运行被测程序，使得程序中<mark style="background: #FF5582A6;">每个语句</mark>至少都能被执行一次。 “语句覆盖”是一个<mark style="background: #FF5582A6;">比较弱的测试标准</mark>。
						- 语句覆盖只关心判定表达式的值，而没有分别测试当判定表达式中每个条件取不同值的情况。显然当 条件有错误发现不了，因此，语句覆盖是很弱的逻辑覆盖。
					2. 判定覆盖（分支覆盖）
						- 判定覆盖又叫分支覆盖，它的含义是，不仅<mark style="background: #FF5582A6;">每个语句</mark>必须至少执行一次，而且<mark style="background: #FF5582A6;">每个判定的每种可能</mark>的结果都应该至少执行 一次，也就是<mark style="background: #FF5582A6;">每个判定的每个分支</mark>都至少执行一次。
						- 判定覆盖只关心整个判定表达式的值，而判定表达式中的各个条件可能的值并没有考虑到。
					3. 条件覆盖
						- 条件覆盖的含义是，<mark style="background: #FF5582A6;">使判定表达式中的每个条件都取到各种可能的结果</mark>（真或假）。
						- 条件覆盖通常比判定覆盖强，因为它使判定表达式中每个条件都取到了两个不同的结果，判定覆盖却只关心整个判定表达式的值。
						- 有时候满足条件覆盖标准的测试用例，并不一定满 足判定覆盖标准，有些判定总是为真或为假。
					4. 判定 / 条件覆盖
						- 判定 / 条件覆盖能同时满足<mark style="background: #FF5582A6;">判定覆盖</mark>和<mark style="background: #FF5582A6;">条件覆盖</mark>两种覆盖的标准。它的含义是，选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果
						- “ 判定／条件覆盖”似乎是比较合理的，但事实并非如此，因为大多数计算机不能用一条指令对多个条 件作出判定，而必须将源程序中对多个条件的判定分解成几个简单判定。
						- 判定 / 条件覆盖每一个条件的每种可能没有<mark style="background: #FF5582A6;">真正获得执行的机会</mark>。
					5. 条件组合覆盖（路径覆盖）
						- 含义是选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。
						- 条件组合覆盖所测试的情况最多，但是选择用例较多。相对难度也大些。
						- 满足条件组合覆盖标准的测试数据 ，也一定满足判定覆盖、条件覆盖和判定 / 条件覆盖标准。因此，条件组合覆盖是前述几种覆盖标准中最强的。但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到。所以我们还需要用其他的测试方法 ( 如黑盒法 ) 作补充。
- 黑盒测试与白盒测试比较
	1. 黑盒测试是从用户观点，按规格说明书要 求的输入数据与输出数据的对应关系设计测试 用例 , 是根据程序外部特征进行测试。
	2. 白盒测试是根据程序内部逻辑结构进行测试。
	3. 黑盒测试与白盒测试优缺点比较
		![[Pasted image 20230625161103.png]]
	4. 黑盒测试与白盒测试
		- 不论黑盒还是白盒测试都不能进行穷尽测试 , 所以软件测试不可能发现程序中存在的所有错误 , 因此需精心设计测试方案 , 力争尽可能少的次数 , 测出尽可能多的错误
	5. 黑盒测试与白盒测试能发现的错误
		![[Pasted image 20230625161152.png]]
	6. 综合测试策略：
		- 白盒法和黑盒法各有长处和短处，每种方法 都可提供一组有用的测试用例，这组测试用例容易 发现某种类型的错误，但不易发现其他类型的错误 ，然而没有一种方法能提供一组“完整的”测试用 例。因此，实际软件测试方案设计是不同方法的综 合应用。
		- 在任何情况下首选边界值分析的方法 ( 这个方法 应对输入和输出的边界值进行析 );
		- 必要时用等价类划分方法补充测试用例 ;
		- 必要时再用错误推测法附加测试用例
		- 检查上述已经设计出的测试方案 , 若未能满足某 些覆盖标准 , 则利用逻辑覆盖补充足够的测试用例
		- 一般要求语句覆盖程度到达 100%, 判定覆盖达到 90%.
- 循环测试
	1. 除了选择结构外，循环也是程序的主要逻辑结构， 要覆盖含有循环结构的所有路径是不可能的，但可通过控制循环次数来测试。
	2. 在结构化的程序中通常有 3 种循环类型：简单循环、串接循环、嵌套循环。
		- 简单循环
			1. ![[Pasted image 20230624181955.png]]
			2. 可采用下列测试集来测试简单循环：
				- 零次循环：从循环入口到出口
				- 一次循环：检查循环初始值
				- m 次循环：检查在多次循环
				- 最大次数循环、比最大次数多一 次、少一次的循环。
		- 串接循环
			1. ![[Pasted image 20230624182057.png]]
			2. 如果各个循环互相独立，则可以用与简单循环相同的方法进行测试。但如果几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理。
		- 嵌套循环
			1. ![[Pasted image 20230624182051.png]]
			2. 对最内层循环做简单循环的全部测试。所有其它层的循环变量置为最小值；
			3. 逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取“典型”值；
			4. 反复进行，直到所有各层循环测试完毕；
			5. 对全部各层循环同时取最小循环次数，或者同时 取最大循环次数。
- 基本路径测试（了解）
	1. 逻辑覆盖测试引导人们把注意力集中在程序的各个判定部分，抓住了程序测试的重点，但是另一方面，它却忽略了另一个对测试也有重要影响的方面——程序的执行路径。随着程序结构复杂性的增长和测试技术的发展，人们逐渐认识到这种忽略所带来的缺陷。于是路径测试方法便应运而生。
	2. 基本路径测试是在程序控制流程图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，从而设计测试用例。设计出的测试用例保证这些路径至少通过一次。
	3. 覆盖
		- 点覆盖
			1. 定义：如果连通图 G 的子图 G′ 是连通的，而且包含 G 的所有结点，则称 G′ 是 G 的点覆盖。
			2. 点覆盖是选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次，由于流图的每个结点与一条或多条语句相对应，显然，点覆盖标准和语句覆盖标准是相同的。
		- 边覆盖
			1. 定义：边覆盖的定义是：如果连通图 G 的子图 G″ 是连通的，而且包含 G 的所有边，则称 G″ 是 G 的边覆盖。 为了满足边覆盖的测试标准，要求选取足够多测试 数据，使得程序执行路径至少经过流图中每条边一次。通常边覆盖和判定覆盖是一致的。
		- 路径覆盖
			1. 含义：路径覆盖的含义是，选取足够多测试数据，使程序的每条可能路径都至少执行一次 (如果程序图中有环，则要求每个环至少经过一次) 。
	4. 使用基本路径测试技术设计测试用例的步骤如下：
		- 根据详细设计结果或源程序画出相应的程序图（也称为流图）；
		- 计算程序图 G 的环形复杂度 V(G) 。环形复 杂度定量度量程序的逻辑复杂性；
		- 确定线性独立路径的基本集合；
		- 导出测试用例；
		- 准备测试用例，确保基本路径集中的每一 条路径的执行。